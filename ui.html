<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI System Prototype</title>
    <style>
        :root {
            --border-size: 24px;
            /* Must match border-image-width */
            --corner-radius: 12px;
            /* Approximate inner curve if needed */
        }

        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            /* Prevent scrollbars from full screen noise */
        }

        /* body::before removed - we use JS specific random noise now */

        /*
           The Container controls the size and holds the border-image.
           It does NOT have the blur itself, to avoid blurring outside the border.
        */
        /* 
           The Container controls the size and holds the border-image.
           It does NOT have the blur itself, to avoid blurring outside the border.
        */
        .ui-frame {
            position: absolute;
            /* Changed to absolute for dragging */
            /* Start at a fixed position to avoid translate jumping */
            top: 100px;
            left: 100px;

            width: 400px;
            height: 300px;

            /* The 9-Slice Border */
            border: var(--border-size) solid transparent;
            /* Default to the USER'S image (even with red pixels) so they know it loaded */
            border-image-source: url('Assets/Image/frame.png');
            border-image-slice: 16 fill;
            border-image-width: var(--border-size);
            border-image-repeat: stretch;

            padding: 20px;
            box-sizing: border-box;
            color: white;
            cursor: move;
            /* Indicate draggable */
            user-select: none;
            /* Prevent text selection while dragging */

            /* Stacking Context Fix */
            z-index: 100;
            isolation: isolate;
        }

        /* 
           The Blur Zone
           Now uses CSS MASKS to restrict the blur to exactly the shape of the "Red Area".
           We use 'mask-border' (or -webkit-mask-box-image) to 9-slice the mask 
           just like the frame border-image.
        */
        .ui-blur-zone {
            position: absolute;
            /* Fill the entire element to extend into the border area */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            pointer-events: auto;
            /* Capture clicks for dragging (bubbles to parent) */

            /* The Blur Effect */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            /* background-color: rgba(0, 0, 0, 0.3); REMOVED TINT */

            /* The Mask Logic (9-Slice Mask) */
            /* We start with placeholder, JS upgrades it to the generated mask */
            -webkit-mask-box-image-source: url('Assets/Image/frame.png');
            -webkit-mask-box-image-slice: 16 fill;
            -webkit-mask-box-image-width: var(--border-size);
            -webkit-mask-box-image-repeat: stretch;

            /* Standard property */
            mask-border-source: url('Assets/Image/frame.png');
            mask-border-slice: 16 fill;
            mask-border-width: var(--border-size);
            mask-border-repeat: stretch;

            /* Expand to cover the border area */
            margin: calc(var(--border-size) * -1);
        }

        .ui-inner {
            position: relative;
            z-index: 1;
            /* Above blur */
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
            /* Let drags pass through container logic */
        }

        /* Re-enable pointer events for interactive children */
        .btn,
        h2,
        p {
            pointer-events: auto;
        }

        /* Text Styles */
        h2 {
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .btn {
            margin-top: auto;
            padding: 10px;
            background: #555;
            border: 2px solid #fff;
            cursor: pointer;
            color: white;
            transition: 0.2s;
        }

        .btn:hover {
            background: #777;
        }

        .ui-frame.placeholder-mode {
            border: 4px solid #888;
            border-image: none;
        }
    </style>
</head>

<body>

    <div id="warnBanner" style="display:none; background:red; color:white; padding:10px; text-align:center;"></div>

    <!-- UI Component Example -->
    <div class="ui-frame" id="testFrame">
        <!-- Masked Blur Layer -->
        <div class="ui-blur-zone" id="blurLayer"></div>

        <!-- Actual UI Elements -->
        <div class="ui-inner">
            <h2>Inventory</h2>
            <p>Item: <strong>Lazor Pickaxe</strong></p>
            <p>Durability: 9000/9001</p>
            <p><i>"A shiny tool for a shiny person."</i></p>
            <button class="btn">Close</button>
        </div>
    </div>

    <script>
        // --- Dragging Logic ---
        const uiFrame = document.getElementById('testFrame');
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // ... (Noise Generation omitted for brevity, logic unchanged) ... Note: keeping existing functions if not replacing them.
        // Wait, replace_file_content replaces the whole block. I need to be careful not to delete generateRandomNoise if I target lines 152-325.
        // I will match the content carefully.

        // --- Red Key Processor ---
        const frameUrl = 'Assets/Image/frame.png';

        const img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
            try {
                const w = img.width;
                const h = img.height;
                const warnBanner = document.getElementById('warnBanner');
                if (warnBanner) warnBanner.style.display = 'none';

                // --- 1. Dynamic Slice Calculation ---
                // Default 1/3 of image size to handle small pixel art
                let sliceSize = Math.floor(Math.min(w, h) / 3);
                if (sliceSize < 1) sliceSize = 1;

                const frameEl = document.getElementById('testFrame');
                const blurEl = document.getElementById('blurLayer');
                console.log(`UI Debug: Image ${w}x${h}, Slice: ${sliceSize}px`);

                let finalFrameUrl, finalMaskUrl;

                try {
                    // Canvas 1: The Visual Frame (Red Removed)
                    const canvasFrame = document.createElement('canvas');
                    canvasFrame.width = w; canvasFrame.height = h;
                    const ctxFrame = canvasFrame.getContext('2d');
                    ctxFrame.drawImage(img, 0, 0);

                    // Canvas 2: The Blur Mask (Only Red Exists)
                    const canvasMask = document.createElement('canvas');
                    canvasMask.width = w; canvasMask.height = h;
                    const ctxMask = canvasMask.getContext('2d');
                    const maskData = ctxMask.createImageData(w, h);
                    const mData = maskData.data;

                    const frameData = ctxFrame.getImageData(0, 0, w, h);
                    const fData = frameData.data;

                    // ... Processing Pixel Data (Red Check) ...
                    for (let i = 0; i < fData.length; i += 4) {
                        const r = fData[i], g = fData[i + 1], b = fData[i + 2], a = fData[i + 3];
                        if (r > 200 && g < 40 && b < 40 && a > 0) {
                            fData[i + 3] = 0; // Transparent
                            mData[i] = mData[i + 1] = mData[i + 2] = 0; mData[i + 3] = 255; // Mask Opaque
                        } else {
                            mData[i + 3] = 0; // Mask Transparent
                        }
                    }

                    ctxFrame.putImageData(frameData, 0, 0);
                    ctxMask.putImageData(maskData, 0, 0);

                    finalFrameUrl = canvasFrame.toDataURL();
                    finalMaskUrl = canvasMask.toDataURL();

                } catch (securityErr) {
                    console.warn("Canvas Tainted (SecurityError) - using raw image fallback.");
                    if (warnBanner) {
                        warnBanner.style.display = 'block';
                        warnBanner.innerText = "Security Warning: Local file access prevented advanced masking. Using fallback.";
                    }
                    // Fallback: Use raw image. Red pixels will be visible, but border will exist.
                    finalFrameUrl = frameUrl;
                    finalMaskUrl = frameUrl; // Mask won't be perfect but better than nothing
                }

                // Apply CSS
                frameEl.style.borderImage = `url(${finalFrameUrl}) ${sliceSize} fill / var(--border-size) stretch`;
                const maskVal = `url(${finalMaskUrl}) ${sliceSize} fill / var(--border-size) stretch`;
                blurEl.style.webkitMaskBoxImage = maskVal;
                blurEl.style.maskBorder = maskVal;

            } catch (err) {
                console.error("UI Script Error:", err);
                const warnBanner = document.getElementById('warnBanner');
                if (warnBanner) {
                    warnBanner.style.display = 'block';
                    warnBanner.innerText = "Critical Error: " + err.message;
                }
            }
        };

        img.onerror = function () {
            console.warn("frame.png not found.");
            document.getElementById('testFrame').classList.add('placeholder-mode');
        };

        img.src = frameUrl;
    </script>

</body>

</html>