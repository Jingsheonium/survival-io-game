<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI System Prototype</title>
    <style>
        :root {
            --border-size: 24px;
            /* Must match border-image-width */
            --corner-radius: 12px;
            /* Approximate inner curve if needed */
        }

        body {
            background-color: #222;
            /* Pixel Noise Background to test Blur */
            background-image:
                linear-gradient(45deg, #333 25%, transparent 25%),
                linear-gradient(-45deg, #333 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #333 75%),
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            /* Add some colored noise dots */
            position: relative;
        }

        /* Pseudo-element for extra colorful noise */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: radial-gradient(#ff0000 10%, transparent 10%),
                radial-gradient(#00ff00 10%, transparent 10%),
                radial-gradient(#0000ff 10%, transparent 10%);
            background-size: 50px 50px;
            background-position: 0 0, 15px 15px, 30px 30px;
            pointer-events: none;
            z-index: -1;
            opacity: 0.5;
        }

        /* 
           The Container controls the size and holds the border-image.
           It does NOT have the blur itself, to avoid blurring outside the border.
        */
        .ui-frame {
            position: relative;
            width: 400px;
            height: 300px;

            /* The 9-Slice Border */
            border: var(--border-size) solid transparent;
            border-image-source: url('Assets/Image/ui_frame_placeholder.png');
            /* JS replaces this */
            border-image-slice: 8 fill;
            /* 'fill' is crucial to draw the center */
            border-image-width: var(--border-size);
            border-image-repeat: stretch;

            padding: 20px;
            box-sizing: border-box;
            color: white;

            /* No overflow hidden, otherwise border might get clipped */
        }

        /* 
           The Blur Zone
           Positioned ABSOLUTELY to match the 'Red Area' (Content Box).
           We use negative inset to pull it to the edge of the padding box/border box?
           Actually, border-image paints in the BORDER area.
           The content box is inside.
           If we want to blur exactly where the red center was (which replaced the content area + border center):
           We should position this to cover the background of the element.
        */
        .ui-blur-zone {
            position: absolute;
            /* Inset 0 relative to the padding-box (inside the border) */
            /* But borders are transparent in 8-slice logic? No, they take space. */
            /* We want to blur the "Inner" area. */
            /* If the border is 24px, we inset by -something? or just fill? */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;

            /* Use z-index -1 to sit behind text but on top of 'border-image fill' (if fill was separate) */
            /* Wait, border-image 'fill' is drawn BENEATH content. */
            /* So we need this blur layer to be *behind* text. */
            z-index: -1;

            /* The Blur Effect */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background-color: rgba(0, 0, 0, 0.3);
            /* Slight tint */

            /* Optional: Match rounded corners of the red area if implied */
            border-radius: var(--corner-radius);
        }

        .ui-inner {
            position: relative;
            z-index: 1;
            /* Above blur */
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Text Styles */
        h2 {
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            margin-top: 0;
            text-align: center;
        }

        .btn {
            margin-top: auto;
            padding: 10px;
            background: #555;
            border: 2px solid #fff;
            cursor: pointer;
            color: white;
            transition: 0.2s;
        }

        .btn:hover {
            background: #777;
        }

        .ui-frame.placeholder-mode {
            border: 4px solid #888;
            border-image: none;
        }
    </style>
</head>

<body>

    <!-- UI Component Example -->
    <div class="ui-frame" id="testFrame">
        <!-- Constrained Blur Layer -->
        <!-- This sits inside the element (padding box). 
             Since border is 24px and box-sizing is border-box, this fills the 352x252 inner area.
             This matches the "Center" of the 9-slice. -->
        <div class="ui-blur-zone"></div>

        <!-- Actual UI Elements -->
        <div class="ui-inner">
            <h2>Inventory</h2>
            <p>Item: <strong>Lazor Pickaxe</strong></p>
            <p>Durability: 9000/9001</p>
            <p><i>"A shiny tool for a shiny person."</i></p>
            <button class="btn">Close</button>
        </div>
    </div>

    <script>
        // "Red Key" Processor
        // This script loads the frame image, looks for Pure Red (255,0,0),
        // and turns it transparent (so the backdrop-filter blur shows through).

        const frameUrl = 'Assets/Image/frame.png'; // Will look for this file

        const img = new Image();
        img.crossOrigin = "Anonymous";

        img.onload = function () {
            // Create a canvas to process the image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;

            // Draw original image
            ctx.drawImage(img, 0, 0);

            // Get pixel data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            let hasRed = false;

            // Scan for Red (255, 0, 0)
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Tolerance could be added, but user said "bright red"
                if (r > 240 && g < 10 && b < 10) {
                    data[i + 3] = 0; // Alpha = 0 (Transparent)
                    hasRed = true;
                }
            }

            if (hasRed) {
                console.log("Detected Red Mask! Applying chroma key...");
                ctx.putImageData(imageData, 0, 0);

                // Convert processed canvas to data URL
                const newUrl = canvas.toDataURL();

                // Apply to the frame
                const frameEl = document.getElementById('testFrame');
                frameEl.style.borderImageSource = `url('${newUrl}')`;
                frameEl.classList.remove('placeholder-mode');
            } else {
                console.log("No red mask found, using image as-is.");
                document.getElementById('testFrame').style.borderImageSource = `url('${frameUrl}')`;
            }
        };

        img.onerror = function () {
            console.warn("frame.png not found yet. waiting for upload...");
            // Keep placeholder styling defined in CSS
            document.getElementById('testFrame').classList.add('placeholder-mode');
            document.getElementById('testFrame').style.borderImageSource = 'none';
        };

        img.src = frameUrl;
    </script>

</body>

</html>