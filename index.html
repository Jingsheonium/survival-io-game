<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Dual-Grid Auto-Tiling - Infinite World</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: monospace;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>
    <div id="ui">
        <div>WASD - Move</div>
        <div>G - Toggle Grid</div>
        <div id="pos"></div>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        canvas.width = 800;
        canvas.height = 600;

        // DUAL GRID CONSTANTS
        const TILE_SIZE = 16;
        const CHUNK_SIZE = 16; // 16x16 tiles per chunk
        const CHUNK_PIXEL_SIZE = CHUNK_SIZE * TILE_SIZE;

        // Load tilesheets
        const grassImg = new Image();
        grassImg.src = 'src/Assets/grass.png';

        const dirtImg = new Image();
        dirtImg.src = 'src/Assets/dirt.png';

        // TILE SELECTOR SYSTEM
        // Extracts individual tiles from a spritesheet
        const TILE_SHEET_CONFIG = {
            tileSize: 16,        // Each tile is 16x16 pixels
            tilesPerRow: 4,      // 4 tiles across
            tilesPerColumn: 4    // 4 tiles down (total 16 tiles, indexed 0-15)
        };

        /**
         * Draw a specific tile from the spritesheet
         * @param {CanvasRenderingContext2D} ctx - Canvas context to draw on
         * @param {Image} spritesheet - The loaded spritesheet image
         * @param {number} tileIndex - Tile index (0-based, 0 = top-left)
         * @param {number} destX - Destination X on canvas
         * @param {number} destY - Destination Y on canvas
         * @param {number} destSize - Size to draw the tile (default 16)
         */
        function drawTile(ctx, spritesheet, tileIndex, destX, destY, destSize = TILE_SIZE) {
            if (!spritesheet.complete || !spritesheet.naturalWidth) return;

            const { tileSize, tilesPerRow } = TILE_SHEET_CONFIG;

            // Convert tile index to row/column (0-based)
            const row = Math.floor(tileIndex / tilesPerRow);
            const col = tileIndex % tilesPerRow;

            // Calculate source position in spritesheet
            const srcX = col * tileSize;
            const srcY = row * tileSize;

            // Draw the tile
            ctx.drawImage(
                spritesheet,
                srcX, srcY, tileSize, tileSize,  // Source rectangle
                destX, destY, destSize, destSize  // Destination rectangle
            );
        }

        /**
         * Seeded random number generator for consistent dirt tile selection
         * Same world position always gets same dirt tile
         */
        function seededRandom(x, y) {
            const seed = x * 374761393 + y * 668265263;
            let value = Math.sin(seed) * 43758.5453;
            return value - Math.floor(value);
        }

        /**
         * Get random dirt tile index for a world position
         * @param {number} worldX - World tile X coordinate
         * @param {number} worldY - World tile Y coordinate
         * @returns {number} Dirt tile index (0-15)
         */
        function getDirtTileIndex(worldX, worldY) {
            const random = seededRandom(worldX, worldY);
            return Math.floor(random * 16); // 16 dirt tiles (0-15)
        }

        // PERLIN NOISE IMPLEMENTATION
        class PerlinNoise {
            constructor(seed = 12345) {
                this.seed = seed;
                this.p = this.buildPermutationTable();
            }

            buildPermutationTable() {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;

                // Shuffle using seed
                let seed = this.seed;
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 9301 + 49297) % 233280;
                    const j = Math.floor((seed / 233280) * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }

                // Duplicate
                for (let i = 0; i < 256; i++) p[256 + i] = p[i];
                return p;
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const a = this.p[X] + Y;
                const aa = this.p[a];
                const ab = this.p[a + 1];
                const b = this.p[X + 1] + Y;
                const ba = this.p[b];
                const bb = this.p[b + 1];

                return this.lerp(v,
                    this.lerp(u, this.grad(this.p[aa], x, y), this.grad(this.p[ba], x - 1, y)),
                    this.lerp(u, this.grad(this.p[ab], x, y - 1), this.grad(this.p[bb], x - 1, y - 1))
                );
            }

            octaveNoise(x, y, octaves = 4, persistence = 0.5) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }

                return total / maxValue;
            }
        }

        const perlin = new PerlinNoise(42);

        // CHUNK SYSTEM
        const chunks = new Map();

        function getChunkKey(chunkX, chunkY) {
            return `${chunkX},${chunkY}`;
        }

        function generateChunk(chunkX, chunkY) {
            const tiles = [];

            for (let y = 0; y < CHUNK_SIZE; y++) {
                tiles[y] = [];
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldY = chunkY * CHUNK_SIZE + y;

                    // Use Perlin noise to determine tile type
                    const noise = perlin.octaveNoise(worldX * 0.05, worldY * 0.05, 4);

                    // 0 = grass, 1 = dirt
                    tiles[y][x] = noise > 0.2 ? 1 : 0;
                }
            }

            return { x: chunkX, y: chunkY, tiles };
        }

        function getChunk(chunkX, chunkY) {
            const key = getChunkKey(chunkX, chunkY);
            if (!chunks.has(key)) {
                chunks.set(key, generateChunk(chunkX, chunkY));
            }
            return chunks.get(key);
        }

        function getTile(worldX, worldY) {
            const chunkX = Math.floor(worldX / CHUNK_SIZE);
            const chunkY = Math.floor(worldY / CHUNK_SIZE);
            const localX = ((worldX % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
            const localY = ((worldY % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

            const chunk = getChunk(chunkX, chunkY);
            return chunk.tiles[localY][localX];
        }

        // AUTO-TILING: Get neighbors and calculate bitmask
        function getNeighborBitmask(worldX, worldY) {
            const center = getTile(worldX, worldY);
            if (center === 0) return 0; // Grass doesn't need auto-tiling

            // Check 8 neighbors (N, NE, E, SE, S, SW, W, NW)
            const n = getTile(worldX, worldY - 1) === center ? 1 : 0;
            const ne = getTile(worldX + 1, worldY - 1) === center ? 1 : 0;
            const e = getTile(worldX + 1, worldY) === center ? 1 : 0;
            const se = getTile(worldX + 1, worldY + 1) === center ? 1 : 0;
            const s = getTile(worldX, worldY + 1) === center ? 1 : 0;
            const sw = getTile(worldX - 1, worldY + 1) === center ? 1 : 0;
            const w = getTile(worldX - 1, worldY) === center ? 1 : 0;
            const nw = getTile(worldX - 1, worldY - 1) === center ? 1 : 0;

            // Simplified 16-tile bitmask (only cardinal directions)
            return (n << 3) | (e << 2) | (s << 1) | w;
        }

        // Map bitmask to tile index in spritesheet
        function getTileIndex(bitmask) {
            // Simplified mapping for 16 tiles
            // You can expand this based on your actual tilesheet layout
            return bitmask;
        }

        // Player
        const player = {
            x: 0,
            y: 0,
            width: 14,
            height: 14,
            speed: 150
        };

        // Camera
        const camera = { x: 0, y: 0 };

        // Input
        const keys = {};
        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Collision check - no collision for grass/dirt terrain
        function checkCollision(x, y, width, height) {
            return false; // Both grass and dirt are walkable
        }

        let lastTime = performance.now();

        function gameLoop(time) {
            requestAnimationFrame(gameLoop);
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // Movement
            let moveX = 0, moveY = 0;
            if (keys['a']) moveX = -1;
            if (keys['d']) moveX = 1;
            if (keys['w']) moveY = -1;
            if (keys['s']) moveY = 1;

            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.707;
                moveY *= 0.707;
            }

            const nextX = player.x + moveX * player.speed * dt;
            const nextY = player.y + moveY * player.speed * dt;

            if (!checkCollision(nextX, player.y, player.width, player.height)) {
                player.x = nextX;
            }
            if (!checkCollision(player.x, nextY, player.width, player.height)) {
                player.y = nextY;
            }

            // Camera follow
            camera.x += (player.x - canvas.width / 2 - camera.x) * 5 * dt;
            camera.y += (player.y - canvas.height / 2 - camera.y) * 5 * dt;

            // RENDER
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate visible chunks
            const startChunkX = Math.floor((camera.x - TILE_SIZE) / CHUNK_PIXEL_SIZE);
            const endChunkX = Math.ceil((camera.x + canvas.width + TILE_SIZE) / CHUNK_PIXEL_SIZE);
            const startChunkY = Math.floor((camera.y - TILE_SIZE) / CHUNK_PIXEL_SIZE);
            const endChunkY = Math.ceil((camera.y + canvas.height + TILE_SIZE) / CHUNK_PIXEL_SIZE);

            // Render visible chunks using VISUAL MAP with offset
            for (let cy = startChunkY; cy < endChunkY; cy++) {
                for (let cx = startChunkX; cx < endChunkX; cx++) {
                    const chunk = getChunk(cx, cy);

                    for (let ty = 0; ty < CHUNK_SIZE; ty++) {
                        for (let tx = 0; tx < CHUNK_SIZE; tx++) {
                            const worldX = cx * CHUNK_SIZE + tx;
                            const worldY = cy * CHUNK_SIZE + ty;

                            // VISUAL MAP: Render with 0.5 tile offset
                            // This creates smooth transitions between tile types
                            const visualX = worldX + 0.5;
                            const visualY = worldY + 0.5;

                            const screenX = visualX * TILE_SIZE - camera.x;
                            const screenY = visualY * TILE_SIZE - camera.y;

                            const tileType = chunk.tiles[ty][tx];

                            // Sample 4 surrounding world tiles to determine visual tile
                            const nw = getTile(Math.floor(visualX - 0.5), Math.floor(visualY - 0.5));
                            const ne = getTile(Math.floor(visualX + 0.5), Math.floor(visualY - 0.5));
                            const sw = getTile(Math.floor(visualX - 0.5), Math.floor(visualY + 0.5));
                            const se = getTile(Math.floor(visualX + 0.5), Math.floor(visualY + 0.5));

                            // LAYER 1: Draw random dirt tile as background
                            const dirtTileIndex = getDirtTileIndex(worldX, worldY);
                            drawTile(ctx, dirtImg, dirtTileIndex, screenX, screenY);

                            // LAYER 2: Grass tiles will go here later (with transparent dirt parts)
                            // For now, just showing the dirt background
                        }
                    }
                }
            }

            // Player
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(player.x - camera.x, player.y - camera.y, player.width, player.height);
            ctx.strokeStyle = '#c92a2a';
            ctx.lineWidth = 2;
            ctx.strokeRect(player.x - camera.x, player.y - camera.y, player.width, player.height);

            // Grid overlay
            if (keys['g']) {
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                const startX = Math.floor(camera.x / TILE_SIZE) * TILE_SIZE;
                const startY = Math.floor(camera.y / TILE_SIZE) * TILE_SIZE;
                for (let x = startX; x < camera.x + canvas.width; x += TILE_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x - camera.x, 0);
                    ctx.lineTo(x - camera.x, canvas.height);
                    ctx.stroke();
                }
                for (let y = startY; y < camera.y + canvas.height; y += TILE_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y - camera.y);
                    ctx.lineTo(canvas.width, y - camera.y);
                    ctx.stroke();
                }
            }

            // UI
            document.getElementById('pos').textContent =
                `Pos: ${Math.floor(player.x)}, ${Math.floor(player.y)} | Chunks: ${chunks.size}`;
        }

        gameLoop(performance.now());
    </script>
</body>

</html>